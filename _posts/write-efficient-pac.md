title: 基于高性能Pac实现智能代理
date: 2015-02-12 14:00:00
categories: network
tags: [pac, openwrt, js]
---

## 相关说明

Pac文件即Proxy auto-config file，实质上是一个javascript脚本。浏览器在连接互联网时会调用其中的FindProxyForURL(url, host)函数，并根据其返回值决定访问特定url时的代理设置。

由于Pac文件实质上是一个javascript脚本，如果我们把它放在某个web服务器上，浏览器下载Pac文件时，服务器可以使用gzip压缩等方式减少传输的流量，对Pac文件本身的压缩就没有必要了。然而，如果Pac文件是储存在一个OpenWrt路由器上，储存空间寸土寸金，我们就有必要提前对Pac文件进行压缩了。

在OpenWrt路由器上使用一个Pac文件代替iptables与dnsmasq有几个优势：

1. 性能更好：
    - Pac文件运行在手机、平板电脑、电脑等设备上，iptables与dnsmasq运行在路由器上，前者的CPU、内存均远远好于后者
    - 得益于V8引擎，手机、平板电脑、电脑处理javascript脚本的效率非常高
    - iptables处理ip段匹配时使用的是遍历链表的方式，时间复杂度是O(n)级别，javascript脚本可以使用二分搜索等方式降低时间复杂度到O(logn)
    - dnsmasq处理域名时使用的也是遍历链表的方式，javascript可以使用hasOwnProperty的方式将时间复杂度降低到O(1)

    注：使用ipset进行ip段匹配可以获得更高的匹配效率，有人为dnsmasq提供了一个patch，用哈希表处理域名匹配以获得更高的匹配效率，这两个优化可以显著提升性能。

2. 配置方便：
    - OpenWrt路由器大多自带了网页服务器以提供luci网页配置界面，将Pac文件配置在路由器上只需要将文件放在路由器的/www目录下即可
    - iptables或是dnsmasq的配置需要一定的linux基础，需要ssh登录到路由器上进行配置

3. 扩展性强：
    - Pac文件本质上是一个javascript脚本，利用javascript可以实现负载均衡、根据本机ip地址决定是否进行代理等多种功能

4. 独立性好：
    - Pac文件可以部署在本机，方便在多个网络环境下切换
    - 不依赖经过特定部署的路由器，在校园网环境下可以更加方便

尽管如此，Pac文件也有一些劣势：

1. 使用范围受限：
    - Pac只能处理http与https协议，邮件客户端是无法通过Pac文件实现代理访问
    - SPDY协议对代理与Pac的处理存在问题，受此影响，twitter、facebook客户端无法使用Pac文件进行处理

2. 不能零配置使用：
    - 尽管OpenWrt可以配置Pac自动发现，但OS X中仍然需要勾选一个选项才能实现这个功能

## 域名匹配的高效算法

进行高效域名匹配的关键在于使用hasOwnProperty方法，这个方法以O(1)的时间复杂度进行查找。

比较好的算法是从完整的域名开始匹配，随后逐级向上查找，即先尝试匹配"translate.google.com"，随后尝试匹配"google.com"，最后匹配"com"。

另外一种思路是从根域开始逐级向下查找，顺序与上面的算法相反。

虽然后者的性能比前者好（在处理白名单，让"cn"域名全部直连时，后者只需查找一次，前者需要循环多次），但是灵活性不如前者（后者无法处理只需要让子域名走代理的情况，北大的网络常常有这种奇异现象，比如B站处理登录验证的域名account.bilibili.com需要走代理，但是其他B站的域名都不需要走代理，在这种情况下，只能用前者处理）。

## IP段匹配的高效算法

APNIC提供了各国的IP地址段信息，这些信息由IP地址段起始点和地址段长度组成，比如下面这一条记录：

    apnic|CN|ipv4|101.0.0.0|1024|20110414|allocated

CN代表中国，101.0.0.0是地址段起始点，1024是地址段长度。

最高效的算法是这样的：先用二分查找，找出比目标IP小的最大的地址段起始点，再求出目标IP与这个起始点的距离，最后比较这个距离与地址段长度即可。

IP地址应当被转换为10进制保存，另外地址段长度均为2的幂次方，所以可以被转换为幂来保存，并且用右移代替简单的比较大小，最终的公式变为：

    if (((目标IP - 起始IP) >> 幂次) === 0) {
        retrun True
    } else {
        return False
    }

## 压缩IP段信息

APNIC分配IP地址段的最小单位是256，所有的IP起始点都是xx.xx.xx.0的形式，这意味着我们可以把所有的IP段数据除以256，这样一来IP地址的数值范围就从0-4294967296降低到了0-16777216，Pac文件的体积可以缩小到最初的80%左右。

接下来，将IP起始点的第一组数字作为分组的依据，xx.yy.yy.0只需要保存为yy.yy的十进制形式，数据的范围也就从0-16777216降低到了0-65536，Pac文件的体积可以缩小到最初的40%左右。

在上面提到的IP段匹配算法中，子网掩码是以幂值来保存的，这样长度达10位数的十进制子网掩码数据只需用1位数的幂值来保存，Pac文件的体积可以缩小到最初的25%左右（40kb）。

到此为止的所有压缩都不影响Pac文件的性能，对应的代码在[master](https://github.com/BlackGear/Mono_Pac)分支中。

由于IP地址数据范围在0-65536，可以将其转化为Unicode编码保存。原先用逗号分割的数值可以被保存为字符串保存，大约5000个逗号可以被省略，Pac文件的体积可以缩小到原先的20%左右（30kb）。

由于幂值的范围在0-17之间，假如幂值为0，那么IP地址起始点的yy.yy形式就和目标IP的yy.yy形式一模一样，所以幂值为0的情况是不需要保存的，将1-17转换为对应的十六进制形式保存为字符串，同样可以省略大约5000个逗号，Pac文件可以被压缩到极限17%（20kb）。

此时的代码需要使用charCodeAt方法与parseInt函数，性能会有大约10%的损失，相关代码在[unicode](https://github.com/BlackGear/Mono_Pac/tree/feature/unicode)分支中。

## 另外的压缩思路

Pac文件在第一次被系统调用时相关状态会被保存下来，也就是说将IP数据进行压缩，将解压缩算法放在Pac文件的全局域，这样只会在第一次调用时有性能损失，后续调用不会有损失。

利用[lz-string](http://pieroxy.net/blog/pages/lz-string/index.html)项目可以达到这一效果，不过，经过研究发现这种压缩算法最终文件体积比利用unicode进行压缩的文件体积大4kb左右，主要是解压缩算法占用了一部分体积。
